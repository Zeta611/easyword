// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "../node_modules/rescript/lib/es6/curry.js";
import * as React from "react";
import * as Js_exn from "../node_modules/rescript/lib/es6/js_exn.js";
import * as Firebase from "./Firebase.js";
import * as Belt_Array from "../node_modules/rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "../node_modules/rescript/lib/es6/belt_Option.js";
import * as Caml_option from "../node_modules/rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "../node_modules/rescript/lib/es6/caml_js_exceptions.js";
import * as Firestore from "firebase/firestore";

function streamJargons(order) {
  var match = Firebase.getFirebase(undefined);
  var jargonsCol = Firestore.collection(match.firestore, "jargons");
  var queryConstraint;
  queryConstraint = order.TAG === /* English */0 ? (
      order._0 ? Firestore.orderBy("english", "desc") : Firestore.orderBy("english", undefined)
    ) : (
      order._0 ? Firestore.orderBy("korean", "desc") : Firestore.orderBy("korean", undefined)
    );
  var jargonsQuery = Firestore.query(jargonsCol, queryConstraint);
  return function (callback) {
    return Firestore.onSnapshot(jargonsQuery, (function (snapshot) {
                  return Curry._1(callback, Belt_Array.map(snapshot.docs, (function (doc) {
                                    var init = doc.data();
                                    return {
                                            id: doc.id,
                                            english: init.english,
                                            korean: init.korean
                                          };
                                  })));
                }));
  };
}

function addJargon(english, korean) {
  var match = Firebase.getFirebase(undefined);
  return Firestore.addDoc(Firestore.collection(match.firestore, "jargons"), {
              english: english,
              korean: korean
            });
}

var header = React.createElement("thead", undefined, React.createElement("tr", undefined, React.createElement("th", undefined, "영어"), React.createElement("th", undefined, "한국어")));

function makeRow(param) {
  return React.createElement("tr", {
              key: param.id
            }, React.createElement("td", undefined, param.english), React.createElement("td", undefined, param.korean));
}

function Jargon$Dictionary(Props) {
  var query = Props.query;
  var match = React.useState(function () {
        return [];
      });
  var setJargons = match[1];
  var match$1 = React.useState(function () {
        return {
                TAG: /* English */0,
                _0: /* Ascending */0
              };
      });
  var order = match$1[0];
  React.useEffect((function () {
          var stream = streamJargons(order);
          var unsubscribe = Curry._1(stream, (function (jargons) {
                  return Curry._1(setJargons, (function (param) {
                                return jargons;
                              }));
                }));
          return (function (param) {
                    return Curry._1(unsubscribe, undefined);
                  });
        }), []);
  var matchAll = /.*/;
  var regex;
  try {
    regex = new RegExp(query);
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      Belt_Option.forEach(obj._1.message, (function (prim) {
              console.log(prim);
              
            }));
      regex = matchAll;
    } else {
      throw obj;
    }
  }
  var rows = Belt_Array.keepMap(match[0], (function (jargon) {
          var match = jargon.english.match(regex);
          var match$1 = jargon.korean.match(regex);
          if (match !== null || match$1 !== null) {
            return Caml_option.some(makeRow(jargon));
          }
          
        }));
  return React.createElement("table", {
              className: "content-table"
            }, header, React.createElement("tbody", undefined, rows));
}

var Dictionary = {
  header: header,
  makeRow: makeRow,
  make: Jargon$Dictionary
};

function Jargon$InputForm(Props) {
  var query = Props.query;
  var onChange = Props.onChange;
  return React.createElement("form", undefined, React.createElement("label", undefined, "검색 (정규식)"), React.createElement("input", {
                  type: "text",
                  value: query,
                  onChange: onChange
                }));
}

var InputForm = {
  make: Jargon$InputForm
};

function Jargon(Props) {
  var match = React.useState(function () {
        return "";
      });
  var setQuery = match[1];
  var query = match[0];
  var onChange = function ($$event) {
    var value = $$event.currentTarget.value;
    return Curry._1(setQuery, (function (param) {
                  return value;
                }));
  };
  return React.createElement("div", {
              className: "container"
            }, React.createElement(Jargon$InputForm, {
                  query: query,
                  onChange: onChange
                }), React.createElement(Jargon$Dictionary, {
                  query: query
                }));
}

var make = Jargon;

export {
  streamJargons ,
  addJargon ,
  Dictionary ,
  InputForm ,
  make ,
  
}
/* header Not a pure module */
